(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{349:function(_,v,t){"use strict";t.r(v);var a=t(3),p=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"并发的一些知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发的一些知识点"}},[_._v("#")]),_._v(" 并发的一些知识点")]),_._v(" "),t("h3",{attrs:{id:"_1、并行和并发的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、并行和并发的区别"}},[_._v("#")]),_._v(" 1、并行和并发的区别")]),_._v(" "),t("p",[_._v("并行：并行是指两个时间在同一时间发生，物理上是同是进行的，可以理解为是多个cpu上同时发生的时间；")]),_._v(" "),t("p",[_._v("并发：并发是指在某一个时间段内，多个事件以此发生，时间上是不连续的，可以理解为是一个cpu在某个时间段内处理的多次事件")]),_._v(" "),t("p",[_._v("区别：并行任务之间互不干扰，不存在资源的竞争和等待，而并发任务需要对CPU的资源进行抢夺；")]),_._v(" "),t("p",[_._v("并行执行的任务之间无需切换，各自独立；并发任务会根据系统的调度在CPU执行任务的时候进行合理的切换")]),_._v(" "),t("p",[_._v("为什么要使用并发")]),_._v(" "),t("p",[_._v("1、计算机的硬件水平受到限制，并发编程可以提高cpu的利用率")]),_._v(" "),t("p",[_._v("2、提高程序的性能")]),_._v(" "),t("p",[_._v("3、并发业务可以更好的处理复杂的业务，对多任务进行拆分，简化任务调度")]),_._v(" "),t("p",[_._v("并发编程的缺点")]),_._v(" "),t("p",[_._v("1、频繁的创建和销毁线程，会消耗大量的内存和时间")]),_._v(" "),t("p",[_._v("2、容易带来一些原子性的操作，比如可见性，原子性和有序性问题，导致出现的结果于预期的结果有偏差")]),_._v(" "),t("p",[_._v("3、多线程容易造成死锁，活锁，线程锁和饥饿锁等问题")]),_._v(" "),t("p",[_._v("对于多线程的一些解释：")]),_._v(" "),t("p",[_._v("多线程可以是并发的也可以是并行的，完全取决于设计者和硬件资源；")]),_._v(" "),t("p",[_._v("当cpu资源比较充足的时候，多线程会被分配到不同的cpu，此时是并行的；当cpu资源不充足的时候，可能会在一个cpu上多次重复的切换，此时是并发")]),_._v(" "),t("hr"),_._v(" "),t("h3",{attrs:{id:"_2、线程和进程的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、线程和进程的区别"}},[_._v("#")]),_._v(" 2、线程和进程的区别")]),_._v(" "),t("p",[_._v("进程：1、系统进行资源分配和调度的基本单位")]),_._v(" "),t("p",[_._v("​\t\t\t2、是一个程序的实例，每一个进程都有自己单独的地址空间和内存空间")]),_._v(" "),t("p",[_._v("​\t\t\t3、进程的资源会被该进程的所有线程进行共享")]),_._v(" "),t("p",[_._v("线程：1、是cpu调度和分配的基本单位")]),_._v(" "),t("p",[_._v("​\t\t\t2、是进程中的一个执行路径，无法独立存在，使用的是进程所获得的资源")]),_._v(" "),t("p",[_._v("关系：一个应用程序实例至少有一个进程，一个进程中最少存在一个线程，但是可以拥有多个线程，")]),_._v(" "),t("p",[_._v("​\t\t\t线程之间可以通过进程的共享资源进行数据的访问")]),_._v(" "),t("p",[_._v("区别：1、从本质上来讲，进程是操作系统资源分配的基本单位，而线程是cpu任务调度和执行的基本单位")]),_._v(" "),t("p",[_._v("​\t\t\t2、从地址空间上来讲，系统在运行的时候会为每一个线程分配不同的内存空间，除了cpu会给线程分配必须的资源外，操作系统不会为了线程分配内存，线程所拥有的资源都来自于其所属的进程的资源")]),_._v(" "),t("p",[_._v("​\t\t\t3、从资源利用上来讲，所有的进程之间的资源是互相独立的，无法共享，对于线程而言，只要他们都是隶属于同一个进程，那么他们就可以用过进程来共享资源")]),_._v(" "),t("p",[_._v("​\t\t\t4、通信：进程之间的通信较为复杂，需要通过ipc（管道、信号量、共享内存、消息队列、文件、套接字）等方式进行通信；线程之间的通信仅需要通过通过进程的共享变量就可以")]),_._v(" "),t("p",[_._v("​\t\t\t5、健壮性：每一个进程之间的资源是独立的，进程崩溃不会导致其他进程出现问题；当线程发生崩溃时，会导致整个进程崩溃，稳定性差，并且容易出现死锁等问题；")]),_._v(" "),t("p",[_._v("​\t\t\t6、可维护性：线程的可维护性差，代码难以调试，容易出现问题")]),_._v(" "),t("h5",{attrs:{id:"进程和线程的选择"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程的选择"}},[_._v("#")]),_._v(" 进程和线程的选择")]),_._v(" "),t("p",[_._v("1、对于需要频繁创建和销毁的任务优先先用线程，因为进程的创建和销毁代价比较大")]),_._v(" "),t("p",[_._v("2、需要稳定性的，优先选择进程")]),_._v(" "),t("p",[_._v("3、需要速度优先，优先考虑线程")]),_._v(" "),t("p",[_._v("4、并行性要求很高，优先考虑线程")]),_._v(" "),t("hr"),_._v(" "),t("h3",{attrs:{id:"线程安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[_._v("#")]),_._v(" 线程安全")]),_._v(" "),t("p",[_._v("线程的安全性问题主要体现在三个方面")]),_._v(" "),t("p",[_._v("1、原子性：一个或多个操作在cpu执行的过程中不会被中断的特性")]),_._v(" "),t("p",[_._v("2、可见性：一个线程对于共享变量的修改，另外的线程能够立刻看到")]),_._v(" "),t("p",[_._v("3、有序性：程序的执行能够按照代码的先后顺序执行")]),_._v(" "),t("p",[_._v("导致的原因")]),_._v(" "),t("p",[_._v("1、缓存导致的可见性（其实这个应该是和各层次的硬件对于读写速度的不一致所导致的")]),_._v(" "),t("p",[_._v("2、线程切换带来的原子性")]),_._v(" "),t("p",[_._v("3、编译优化带来的有序性")]),_._v(" "),t("p",[_._v("解决方法：使用atomic的原子类，synchronized等关键字，lock锁 可以解决原子性")]),_._v(" "),t("p",[_._v("synchronized、volatile、LOCK可以解决可见性")]),_._v(" "),t("p",[_._v("heppens-before规则可以解决有序性问题")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"线程的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[_._v("#")]),_._v(" 线程的状态")]),_._v(" "),t("p",[_._v("线程一共有六种状态")]),_._v(" "),t("p",[_._v("1、NEW(初始化)")]),_._v(" "),t("p",[_._v("2、RUNNABLE(可运行/运行状态)")]),_._v(" "),t("p",[_._v("3、BLOCKED(阻塞状态)")]),_._v(" "),t("p",[_._v("4、WAITING（无限时等待）")]),_._v(" "),t("p",[_._v("5、TIMED_WAITING（有限时等待）")]),_._v(" "),t("p",[_._v("6、TERMINATED(终止状态)")]),_._v(" "),t("p",[_._v("其中3、4、5是休眠状态，对于CPU没有使用权")]),_._v(" "),t("p",[_._v("1、一个线程刚刚被创建的时候就是new对象，当执行到thread.start()的时候，就会进入到runnable状态，当一个线程需要等待，或者说在获取资源时需要等待，就会进入到blocked的阻塞状态。当一个线程获取到一个资源的锁，就会再一次进入到runnable状态。")]),_._v(" "),t("p",[_._v("2、当线程调用thread.wait()就会进入到waitting状态，知道对象的notiff() 或者notifyALL()函数被调用，才会从waitting转换到runnable状态。")]),_._v(" "),t("p",[_._v("同理待用join()方法的时候，也会进入到waiting状态，只不过区别在于等到线程执行完毕之后，会自动释放变成runnable 状态")]),_._v(" "),t("p",[_._v("当调用LockSupport.park()的时候，也会由runnable 转换到waitting状态，等到LockSupport.unpark()被调用，才会再一次进入到runnable 状态")]),_._v(" "),t("p",[_._v("3、当执行带有参数的wait、join函数的时候，就可以进入到timed_waitting 状态，超时时间一到，就会转入到runnable状态")]),_._v(" "),t("p",[_._v("4、抛出异常，或者线程函数执行完毕，就会进入到terminated状态")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"java-中的一些锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-中的一些锁"}},[_._v("#")]),_._v(" java 中的一些锁")]),_._v(" "),t("p",[_._v("1、公平锁和非公平锁")]),_._v(" "),t("p",[_._v("公平锁：多个线程之间按照申请的顺序来获取锁")]),_._v(" "),t("p",[_._v("非公平锁：线程之间获取锁的顺序并不按照申请的先后顺序")]),_._v(" "),t("p",[_._v("2、独享锁和共享锁")]),_._v(" "),t("p",[_._v("独享锁：一个锁一次只能被一个线程所持有 synchronized")]),_._v(" "),t("p",[_._v("共享锁：一个锁可以被多个线程同时持有")]),_._v(" "),t("p",[_._v("3、悲观锁和乐观锁")]),_._v(" "),t("p",[_._v("悲观锁：一律都会对代码进行加锁")]),_._v(" "),t("p",[_._v("乐观锁：不会对数据进行上锁，采用cas算法")]),_._v(" "),t("p",[_._v("4、自旋锁")]),_._v(" "),t("p",[_._v("一个线程在获取锁的时候，已经被其他线程获取，那么该线程就会被循环等待，然后不断的判断锁是不是可以被获取成功，知道获取到锁才会退出循环")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"synchronized-和lock的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和lock的区别"}},[_._v("#")]),_._v(" synchronized 和Lock的区别")]),_._v(" "),t("p",[_._v("1、实现的程面不一样")]),_._v(" "),t("p",[_._v("​\tsynchronized是关键字，在jvm层面实现，Lock是在代码层面加锁")]),_._v(" "),t("p",[_._v("2、是否自动释放")]),_._v(" "),t("p",[_._v("synchronized在代码执行完毕后会自动释放锁，Lock不自动释放，需要自己显示的释放")]),_._v(" "),t("p",[_._v("3、是否一直等待")]),_._v(" "),t("p",[_._v("synchronized在拿不到锁的时候会一直等待，lock可以设置超时时间")]),_._v(" "),t("p",[_._v("4、获取到锁成功是否可知")]),_._v(" "),t("p",[_._v("synchronized无法获知是否获取锁成功，Lock可以通过trylock获得加锁是否成功")]),_._v(" "),t("p",[_._v("4、功能复杂度")]),_._v(" "),t("p",[_._v("synchronized加锁可重入，不可中断，非公平；lock可重入，可判断，可公平或不公平")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[_._v("#")]),_._v(" 死锁")]),_._v(" "),t("p",[_._v("死锁是指由于两个或者多个线程相互持有所需要的资源，导致这些线程一直处于等待其他线程释放资源的状态，无法继续执行。如果线程都不主动释放所占有的资源，就会导致其他线程无法获取到该资源，从而造成死锁。")]),_._v(" "),t("p",[_._v("产生原因")]),_._v(" "),t("p",[_._v("1、持有独享的资源，去竞争系统不可被剥夺的资源，从而造成僵死的竞争关系")]),_._v(" "),t("p",[_._v("2、信号量使用不当")]),_._v(" "),t("p",[_._v("如何避免：")]),_._v(" "),t("p",[_._v("1、一次性申请所需要的资源，破坏”占有且等待“的条件")]),_._v(" "),t("p",[_._v("2、当一个资源进一步请求其他资源的时候，如果申请不到，主动释放其占有的资源")]),_._v(" "),t("p",[_._v("3、按照申请顺序分配资源")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"活锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#活锁"}},[_._v("#")]),_._v(" 活锁")]),_._v(" "),t("p",[_._v("可以理解为两个线程都互相拥有对方所需要的资源，在请求资源时失败，就会同时释放自己的资源，但是双发都释放资源后，却又无法执行任务，导致资源一直被释放无法被利用")]),_._v(" "),t("p",[_._v("解决方法：在下一次尝试获取资源之前，休眠一段时间")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"饥饿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#饥饿"}},[_._v("#")]),_._v(" 饥饿")]),_._v(" "),t("p",[_._v("一个线程因为CPU时间全部被其他线程抢占而得不到cpu的时间，导致线程一直无法被执行")]),_._v(" "),t("p",[_._v("产生原因：")]),_._v(" "),t("p",[_._v("1、优先级高的线程吞噬所有低优先级的cpu时间")]),_._v(" "),t("p",[_._v("2、其他线程总能在某个线程之前持续的对资源访问，让线程永远被阻塞")]),_._v(" "),t("p",[_._v("3、其他线程总是能抢先被唤醒，使得线程一直被等待唤醒")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"happen-before原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#happen-before原则"}},[_._v("#")]),_._v(" happen-before原则")]),_._v(" "),t("p",[_._v("1、程序按照代码书写顺序一次执行")]),_._v(" "),t("p",[_._v("2、加锁和解锁的顺序不能混乱，解锁一定要在加锁后")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"slepp-和wait-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slepp-和wait-的区别"}},[_._v("#")]),_._v(" slepp()和wait()的区别")]),_._v(" "),t("p",[_._v("1、sleep是线程的静态方法，但是wait是对象的成员方法")]),_._v(" "),t("p",[_._v("2、sleep可以在任何地方使用，wait只能在同步方法或同步代码块中使用")]),_._v(" "),t("p",[_._v("3、slepp会休眠指定的时间长度，释放cpu资源，但是不会释放锁，休眠时间到达后继续执行；wait会释放对象锁，进入等待队列，等待到nofity或者notifyall方法后才有机会再一次竞争锁，进入运行状态")]),_._v(" "),t("hr"),_._v(" "),t("h4",{attrs:{id:"jdk中atomic开头的原子类实现原子性原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk中atomic开头的原子类实现原子性原理"}},[_._v("#")]),_._v(" jdk中Atomic开头的原子类实现原子性原理")]),_._v(" "),t("p",[_._v("atomic开头的类，是通过CAS原理解决并发情况下的原子性")]),_._v(" "),t("p",[_._v("//todo 待补充")])])}),[],!1,null,null,null);v.default=p.exports}}]);